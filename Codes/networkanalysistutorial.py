# -*- coding: utf-8 -*-
"""NetworkAnalysisTutorial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VqrKq_uMhkaIzxNIDc05P3etx7ma9VhL

### **Network Analysis Tutorial**
## 2023-11-09

## **1. Setting up environment**
"""

## Install or load packages required
!pip install panda
!pip install igraph
!pip install matplotlib

import pandas as pd
import igraph
import matplotlib.pyplot as plt
import matplotlib as mpl

"""## **2. Read in dataset**

*2.1 MalaCard CML dataset from GitHub*
"""

CMLfile="https://raw.githubusercontent.com/chengwailei/YUHS_NetworkAnalysis/main/data/CML_MalaCard_Gene.csv"

CML_keygenes_df=pd.read_csv(CMLfile)

CML_keygenes_df

"""*2.2 STRING interactome datset from STRING*"""

STRINGfile="https://stringdb-downloads.org/download/protein.physical.links.v12.0/9606.protein.physical.links.v12.0.txt.gz"

interactome_df = pd.read_csv(STRINGfile,sep = " ")

interactome_df

"""*2.3 STRING protein alias dataset*"""

STRINGAliasFile="https://stringdb-downloads.org/download/protein.aliases.v12.0/9606.protein.aliases.v12.0.txt.gz"

alias_df = pd.read_csv(STRINGAliasFile, sep = "\t", na_filter= False)

## Rename column names
alias_df.columns = ["protein_name", "alias", "source"]

alias_df

"""## **3. Define the gene of interests**

We are interested in protein encoding genes that are likely pathogeneic in the MalaCard geneset.
"""

CML_keygenes_list = CML_keygenes_df[(CML_keygenes_df["Category"] == "Protein Coding") & (CML_keygenes_df["Evidence"] == "Diseases_inferred")]
CML_keygenes_list = CML_keygenes_list["Symbol"].tolist()

## Extract only unique values
CML_keygenes_list = list(set(CML_keygenes_list))
print(CML_keygenes_list)

"""❓**Time for Question 1 & 2**

Try and edit the code and answer quiz questions 1 and 2 on Slido.

Slido.com: # 1675300

We need to subset to get the Ensembl protein IDs by their gene names. Note that some alias may not have a corresponding protein name. This might be due to the uses of different alias in the interactome or it is not recorded at all.
"""

alias_df_1 = alias_df[alias_df["source"] == "KEGG_NAME"]

keygenes_Ensembl = alias_df_1[alias_df_1["alias"].isin(CML_keygenes_list)]

keygenes_Ensembl_list = keygenes_Ensembl["protein_name"].tolist()
keygenes_Ensembl_list = list(set(keygenes_Ensembl_list))

"""**4. Extract subnetwork**

To extract the CML subnetwork, we keep interactions that involve our genes of interests
"""

CML_network = interactome_df[(interactome_df["protein1"].isin(keygenes_Ensembl_list)) &
                             (interactome_df["protein2"].isin(keygenes_Ensembl_list))]

CML_network

"""We have the list of interactions, which is huge (4,232 interaction). They are not all relevant though. STRING provides a separate column "combined_score" which denotes how confident they are with the interaction. This reflects whether the interaction is simply predicted due to co-mentioning in literature or tested experimentally for their interaction.

A middle, and widely accepted cut-off is 400. We want to aim for a higher confidence at **800**. This can be done by:
"""

CML_network = CML_network[(CML_network["combined_score"] >= 800)]
CML_network

"""❓**Time for Question 3**

Try and answer quiz question 3 on Slido!

Now we have a protein network but the Ensembl Protein IDs are confusing. We can add the alias name from the keygenes_Ensembl that we have generated.
"""

CML_network = pd.merge(CML_network,
              keygenes_Ensembl[["protein_name","alias"]],
              left_on = "protein1",
              right_on = "protein_name")

CML_network.drop("protein_name", inplace = True, axis = 1)

CML_network.columns = ["protein1", "protein2", "combined_score","protein1_alias"]

CML_network = pd.merge(CML_network,
              keygenes_Ensembl[["protein_name","alias"]],
              left_on = "protein2",
              right_on = "protein_name")

CML_network.drop("protein_name", inplace = True, axis = 1)

CML_network.columns = ["protein1", "protein2", "combined_score","protein1_alias", "protein2_alias"]

CML_network

"""**Save network**

To ensure we can retrieve the same result in each run, saving the network would be helpful. This also helps to feed the result to other pipelines.
"""

CML_network.to_csv("CML_network.csv", index=False)

CML_network = pd.read_csv("CML_network.csv")

CML_network

"""**5. Network as network**

*5.1 Converting to network*

Up until now, we are subsetting the network as a datatable (a.k.a edgelist, as the table stores the edges of the data). To run any algorithms, we will need to read it as a network.
The library we are using is igraph, which you should have loaded at the start of the tutorial
"""

## Generate tuple from dataframe
tuples = [tuple(x) for x in CML_network[["protein1_alias", "protein2_alias"]].values]

g = igraph.Graph.TupleList(tuples, directed = False)

"""*5.2 Visualise the graph*"""

fig, ax = plt.subplots()
igraph.plot(g,
            target = ax,
            vertex_size = 2,
            vertex_color = "white",
            edge_color = "grey",
            edge_width = 1,
            edge_arrow_size = 0,
            vertex_label = g.vs["name"],
            vertex_label_size = 8
            )

"""The nodes are all clustered together. The best way to overcome this is to adjust the layout."""

fig, ax = plt.subplots()

lay = g.layout_davidson_harel(weight_edge_lengths = g.density()/1000)

igraph.plot(g.simplify(),
            target = ax,
            layout = lay,
            vertex_size = 2,
            vertex_color = "white",
            edge_color = "grey",
            edge_width = 1,
            edge_arrow_size = 0,
            vertex_label = g.vs["name"],
            vertex_label_size = 8
            )

"""❓**Time for Question 4**

Try and answer quiz question 4 on Slido!

**6. Centrality Measures**

In the previous lectures, we learnt about several centrality scores. The algorithms measure the topology of the network and give us some insights on the node or edge importances. In this exercise, we use the CML network and calculate some centralities we have described.

*6.1 Degree centrality*

Degree centrality measures the number of edges connected to the nodes. We use the `degree()`
function from igraph to calculate the degree centrality of the CML network.
"""

degree_centrality = g.degree()
degree_centrality = dict(zip(g.vs["name"], degree_centrality))

print(sorted(degree_centrality.items(), key=lambda x: x[1], reverse=True))

"""**Visualise network by centrality scores**

We can visualise the degree centrality on the network plot itself.
"""

## function to define colors
minima = min(g.degree())
maxima = max(g.degree())

norm = mpl.colors.Normalize(vmin=minima, vmax=maxima, clip=True)
mapper = mpl.cm.ScalarMappable(norm=norm, cmap=mpl.cm.YlOrBr)

fig, ax = plt.subplots()

g.vs["color"] = [mapper.to_rgba(v) for v in g.degree()]

igraph.plot(g,
            target = ax,
            vertex_size = 10,
            edge_color = "grey",
            edge_width = 1,
            edge_arrow_size = 0,
            vertex_label = g.vs["name"],
            vertex_label_size = 2,
            vertex_color = g.vs['color']
            )

"""*6.2 Closeness centrality*

Closeness centrality describe how far a node is from other nodes. We use the `closeness()` function from igraph to calculate the closeness centrality of the CML network.
"""

closeness_centrality = g.closeness()
closeness_centrality = dict(zip(g.vs["name"], closeness_centrality))

print(sorted(closeness_centrality.items(), key=lambda x: x[1], reverse=True))

"""We see HOXA9, and MEIS1 are amongst the top. They are from the disconnected graph.

❓**Time for Question 5**

Try and answer quiz question 5 on Slido!

*6.3 Betweenness centrality*

Betweenness centrality describe how much influence a node has in the network. We use the `betweenness()` function from igraph to calculate the Betweenness centrality of the CML network.
"""

betweenness_centrality = g.betweenness()
betweenness_centrality = dict(zip(g.vs["name"], betweenness_centrality))

print(sorted(betweenness_centrality.items(), key=lambda x: x[1], reverse=True))

"""❓**Time for Question 6**

Try and answer quiz question 6 on Slido!

*6.4 Eigenvector centrality*

Eigenvector centrality describe how much influence a node has in the network. We use the `evcent()` function from igraph to calculate the Eigenvector centrality of the CML network.

You might notice that the algorithms returns a list of list. To over come this, we need to read into the actual result, which is stored as "vector".
"""

eigenvector_centrality = g.eigenvector_centrality()
eigenvector_centrality = dict(zip(g.vs["name"], eigenvector_centrality))

print(sorted(eigenvector_centrality.items(), key=lambda x: x[1], reverse=True))

"""❓**Time for Question 7**

Try and answer quiz question 7 on Slido!

*6.5 Random Walk Restart/ Personalised PageRank*

We extracted the interactome from a non-disease database, therefore the edges may only be applicable to normal settings. We are interested to disease-associated interactions. One of the ways to do so is to seed RWR from dysregulated protein, in our case BCR and ABL1. (as there is no node called BCR/ABL1)

**Restarting from ABL1**
"""

ABL1_PPR  = g.personalized_pagerank(reset_vertices = ["ABL1"])

ABL1_PPR= dict(zip(g.vs["name"], ABL1_PPR))

print(sorted(ABL1_PPR.items(), key=lambda x: x[1], reverse=True))

"""**Restarting from BCR**

What would the codes be for starting at "BCR" instead of "ABL1"?

❓**Time for Question 8**

Try and answer quiz question 8 on Slido!

**Restarting from BCR and ABL1**
"""

CML_PPR  = g.personalized_pagerank(reset_vertices = ["ABL1","BCR"])

CML_PPR= dict(zip(g.vs["name"], CML_PPR))

print(sorted(CML_PPR.items(), key=lambda x: x[1], reverse=True))

"""❓**Time for Question 9**

Try and answer quiz question 9 on Slido!

**7. Summarising all results**
"""

centrality_result = pd.DataFrame.from_dict([CML_PPR,
                        degree_centrality,
                        eigenvector_centrality,
                        closeness_centrality,
                        betweenness_centrality]).transpose()
centrality_result.columns = ["CML_PPR","degree_centrality","eigenvector_centrality",
                             "closeness_centrality","betweenness_centrality"]

centrality_average = centrality_result.mean(axis=1)
centrality_average.sort_values(ascending = False)

"""❓**Time for Question 10**

Try and answer quiz question 10 on Slido!
"""

